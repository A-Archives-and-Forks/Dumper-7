#include "IDAMappingGenerator.h"

#include <fstream>


std::wstring IDAMappingGenerator::MangleFunctionName(const std::wstring& ClassName, const std::wstring& FunctionName)
{
	return L"_ZN" + std::to_wstring(ClassName.length()) + ClassName + std::to_wstring(FunctionName.length() + 4) + L"exec" + FunctionName + L"Ev";
}

void IDAMappingGenerator::WriteReadMe(StreamType& ReadMe)
{
	ReadMe << R"(
/*
* File generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

Supported: IDA 7.7 and above (including IDA 8.3)

'.idmap' files can be used to import the names of VFTables and Exec functions, with the following plugin:

https://github.com/Fischsalat/IDAExecFunctionsImporter


FileFormat:

An '.idmap' file is just an array of Identifiers. All the plugin does is give variables/functions at a certain offset a certain name.

struct Identifier
{
    uint32 Offset; // Relative to Imagebase
    uint16 NameLength;
    const char Name[NameLength]; // Not NULL-terminated
};
)";
}

void IDAMappingGenerator::GenerateVTableName(StreamType& IdmapFile, UEObject DefaultObject)
{
	UEClass Class = DefaultObject.GetClass();
	UEClass Super = Class.GetSuper().Cast<UEClass>();

	if (Super && DefaultObject.GetVft() == Super.GetDefaultObject().GetVft())
		return;

	std::wstring Name = Class.GetCppName() + L"_VFT";

	uint32 Offset = static_cast<uint32>(GetOffset(DefaultObject.GetVft()));
	uint16 NameLen = static_cast<uint16>(Name.length());

	WriteToStream(IdmapFile, Offset);
	WriteToStream(IdmapFile, NameLen);
	WriteToStream(IdmapFile, Name.c_str(), NameLen);
}

void IDAMappingGenerator::GenerateClassFunctions(StreamType& IdmapFile, UEClass Class)
{
	static std::unordered_map<uint32, std::wstring> Funcs;

	for (UEFunction Func : Class.GetFunctions())
	{
		if (!Func.HasFlags(EFunctionFlags::Native))
			continue;

		std::wstring MangledName = MangleFunctionName(Class.GetCppName(), Func.GetValidName());

		uint32 Offset = static_cast<uint32>(GetOffset(Func.GetExecFunction()));
		uint16 NameLen = static_cast<uint16>(MangledName.length());

		auto [It, bInseted] = Funcs.emplace(Offset, Func.GetFullName());

		if (!bInseted)
		{
			//std::wcout << L"Collision: \nOld: L" << It->second << L"\nNew: L" << Func.GetFullName() << L"\n" << std::endl;
			continue;
		}

		WriteToStream(IdmapFile, Offset);
		WriteToStream(IdmapFile, NameLen);
		WriteToStream(IdmapFile, MangledName.c_str(), NameLen);
	}
}

void IDAMappingGenerator::Generate()
{
	std::wstring IdaMappingFileName = (Settings::Generator::GameVersion + L'-' + Settings::Generator::GameName + L".idmap");

	FileNameHelper::MakeValidFileName(IdaMappingFileName);

	/* Open the stream as binary data, else ofstream will add \r after numbers that can be interpreted as \n. */
	std::wofstream IdmapFile(MainFolder / IdaMappingFileName, std::ios::binary);

	/* Create a ReadMe to describe what '.idmap' is, and how to use it */
	std::wofstream ReadMe(MainFolder / "ReadMe.txt");

	/* Write description of the file format, as well as a link to the IDA-Plugin */
	WriteReadMe(ReadMe);

	for (UEObject Obj : ObjectArray())
	{
		if (Obj.HasAnyFlags(EObjectFlags::ClassDefaultObject))
		{
			/* Gets the VTable offset from the default object and writes the ClassName + L"_VFT" postfix to the file */
			GenerateVTableName(IdmapFile, Obj);
		}
		else if (Obj.IsA(EClassCastFlags::Class))
		{
			/* Iterates all of the functions of the class and them to the stream with an "exec" prefix in front of the function name */
			GenerateClassFunctions(IdmapFile, Obj.Cast<UEClass>());
		}
	}
}